{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-c62f85cb3e8a8369aaafaf7c03a484344ffa46c2",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Reputation.sol": "project/contracts/Reputation.sol",
    "contracts/Request.sol": "project/contracts/Request.sol",
    "contracts/Roles.sol": "project/contracts/Roles.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Reputation.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport \"./Roles.sol\";\n\ncontract Reputation {\n    Roles public roles;\n\n    address public owner;\n    mapping(address => int256) private reputation;\n\n    event ReputationChanged(address indexed who, address indexed by, address justification, int256 delta, int256 newScore);\n    event ReputationSet(address indexed who, address indexed by, int256 oldScore, int256 newScore);\n\n    constructor(address rolesAddress) {\n        owner = msg.sender;\n        roles = Roles(rolesAddress);\n    }\n\n    //Role checks\n    modifier onlyBuyerOrAdmin() {\n        require(roles.hasRole(roles.BUYER_ROLE(), msg.sender) || roles.hasRole(roles.ADMIN_ROLE(), msg.sender), \"buyer only\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(roles.hasRole(roles.ADMIN_ROLE(), msg.sender), \"admin only\");\n        _;\n    }\n\n\n\n    // Buyer can increase reputation\n    function award(address who, address justification) external onlyBuyerOrAdmin() {\n        reputation[who] += 1;\n        emit ReputationChanged(who, msg.sender, justification, 1, reputation[who]);\n    }\n\n    // Buyer can reduce reputation\n    function penalize(address who, address justification) external onlyBuyerOrAdmin {\n        reputation[who] -= 1;\n        emit ReputationChanged(who, msg.sender, justification, -1, reputation[who]);\n    }\n\n    // Admin can set reputation\n    function setScore(address who, int256 newScore) external onlyAdmin {\n        int256 oldScore = reputation[who];\n        reputation[who] = newScore;\n        emit ReputationSet(who, msg.sender, oldScore, newScore);\n    }\n\n    // Can read repitation\n    function reputationOf(address who) external view returns (int256) {\n        return reputation[who];\n    }\n}"
      },
      "project/contracts/Request.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport {Reputation} from \"./Reputation.sol\";\nimport {Roles} from \"./Roles.sol\";\n\n/// @notice Request for computational job.\n/// Role management is delegated to a Roles contract; reputation updates to Reputation contract.\ncontract Request {\n    // External contracts\n    Roles public roles;\n    Reputation public reputation;\n\n    // Involved parties\n    address public owner;\n    address public executor;\n    address public auditor;\n\n    // State machine\n    enum State { Created, ExecutorAssigned, ResultSubmitted, Audited, Completed }\n    State public currentState;\n\n    // Data fields\n    bytes32 public commandHash;\n    bytes32 public resultHash;\n    bytes32 public auditorResultHash;\n    bool public faultyResult;\n\n    // Events\n    event ExecutorAssigned(address indexed account);\n    event AuditorAssigned(address indexed account);\n    event ResultAssigned(bytes32 hash, address indexed by);\n    event AuditorResultAssigned(bytes32 hash, address indexed by);\n    event FaultyCalculationDetected(address indexed auditedBy, address calculatedBy, bytes32 executionHash, bytes32 auditHash);\n    event FaultyCalculationFixed(address indexed auditedBy, address calculatedBy);\n    event RequestFinished(address indexed calculatedBy,address auditedBy, bytes32 resultHash);\n\n    constructor(bytes32 calculatedCommandHash, address rolesAddress, address reputationAddress) {\n        owner = msg.sender;\n        roles = Roles(rolesAddress);\n        reputation = Reputation(reputationAddress);\n\n        require(roles.hasRole(roles.BUYER_ROLE(), msg.sender), \"buyer only\");\n\n        commandHash = calculatedCommandHash;\n        currentState = State.Created;\n    }\n\n//ACCESS\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"owner only\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(roles.hasRole(roles.ADMIN_ROLE(), msg.sender), \"admin only\");\n        _;\n    }\n\n    modifier onlyExecutor() {\n        require(executor == msg.sender, \"executor only\");\n        _;\n    }\n\n    modifier onlyAuditor() {\n        require(auditor == msg.sender, \"auditor only\");\n        _;\n    }\n\n//STATE\n\n    modifier inState(State _state) {\n        require(currentState == _state, \"Invalid state for this operation\");\n        _;\n    }\n\n    modifier transitionTo(State _nextState) {\n        _;\n        currentState = _nextState;\n    }\n\n\n//FUNCTIONS\n\n    /// @notice Admin appoints an executor. Only allowed when request is Created.\n    function appointExecutor(address potentialExecutor)\n        public\n        onlyAdmin\n        inState(State.Created)\n        transitionTo(State.ExecutorAssigned)\n    {\n        require(roles.hasRole(roles.SELLER_ROLE(), potentialExecutor), \"candidate not a seller\");\n        executor = potentialExecutor;\n        emit ExecutorAssigned(potentialExecutor);\n    }\n\n    /// @notice Admin appoints an auditor. Allowed when executor is assigned.\n    function appointAuditor(address potentialAuditor)\n        public\n        onlyAdmin\n        inState(State.ExecutorAssigned)\n    {\n        require(potentialAuditor != executor, \"auditor cannot be executor\");\n        require(roles.hasRole(roles.SELLER_ROLE(), potentialAuditor), \"candidate not a seller\");\n\n        auditor = potentialAuditor;\n        emit AuditorAssigned(potentialAuditor);\n        // remain in ExecutorAssigned state until executor posts result\n    }\n\n    /// @notice Executor posts the computation result. Moves state to ResultSubmitted.\n    function assignResult(bytes32 calculatedResultHash)\n        public\n        onlyExecutor\n        inState(State.ExecutorAssigned)\n        transitionTo(State.ResultSubmitted)\n    {\n        resultHash = calculatedResultHash;\n        emit ResultAssigned(calculatedResultHash, msg.sender);\n\n        // If auditor already posted result, evaluate immediately\n        if (auditorResultHash != bytes32(0)) {\n            if (auditorResultHash == resultHash) {\n                faultyResult = false;\n                emit FaultyCalculationFixed(auditor, executor);\n                currentState = State.Completed; // overwrite transition\n                emit RequestFinished(executor, auditor, resultHash);\n            } else {\n                faultyResult = true;\n                emit FaultyCalculationDetected(auditor, executor, resultHash, auditorResultHash);\n                executor = address(0);\n                currentState = State.Created; // allow retry\n            }\n        }\n    }\n\n    /// @notice Auditor posts audit result. Evaluates and finalizes the request.\n    function assignAuditResult(bytes32 calculatedResultHash)\n        public\n        onlyAuditor\n        inState(State.ResultSubmitted)\n    {\n        auditorResultHash = calculatedResultHash;\n        emit AuditorResultAssigned(calculatedResultHash, msg.sender);\n\n        if (resultHash != calculatedResultHash) {\n            // mismatch: mark faulty, penalize executor and reset executor\n            faultyResult = true;\n            emit FaultyCalculationDetected(auditor, executor, resultHash, auditorResultHash);\n            executor = address(0);\n            // allow re-assignment to try again\n            currentState = State.Created;\n        } else {\n            currentState = State.Completed;\n            emit RequestFinished(executor, auditor, resultHash);\n        }\n    }\n\n//READ\n    /// @notice Get the information of the request \n    function getInformation() external view returns (\n        State state,\n        address owner_,\n        address executor_,\n        address auditor_,\n        bytes32 commandHash_,\n        bytes32 resultHash_,\n        bytes32 auditorResultHash_,\n        bool faultyResult_\n    ) {\n        return (\n            currentState,\n            owner,\n            executor,\n            auditor,\n            commandHash,\n            resultHash,\n            auditorResultHash,\n            faultyResult\n        );\n    }\n}"
      },
      "project/contracts/Roles.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\n/// @notice\n/// - Owner (set at deployment) can grant/revoke roles.\n/// - Emits events so indexers/subgraphs can track role changes.\n/// - ROLES: Buyer / Seller / Admin / Banned\ncontract Roles {\n    // Owner of the role manager\n    address public owner;\n\n    bytes32 public constant ADMIN_ROLE  = keccak256(\"ADMIN\");\n    bytes32 public constant BUYER_ROLE  = keccak256(\"BUYER\");\n    bytes32 public constant SELLER_ROLE = keccak256(\"SELLER\");\n    bytes32 public constant BANNED_ROLE = keccak256(\"BANNED\");\n\n\n    // role => account => hasRole\n    mapping(bytes32 => mapping(address => bool)) private _roles;\n\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed by);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed by);\n    event OwnerTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        owner = msg.sender;\n        _roles[ADMIN_ROLE][owner] = true;\n        emit RoleGranted(ADMIN_ROLE, msg.sender, msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"owner only\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(hasRole(ADMIN_ROLE, msg.sender), \"admin only\");\n        _;\n    }\n\n    /// @notice Returns true if account has role.\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role][account];\n    }\n\n    /// @notice Grant role to account.\n    function grantRole(bytes32 role, address account) public onlyAdmin {\n        if (!_roles[role][account]) {\n            _roles[role][account] = true;\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    /// @notice Revoke role from account.\n    function revokeRole(bytes32 role, address account) public onlyAdmin {\n        if (_roles[role][account]) {\n            _roles[role][account] = false;\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n\n    /// @notice Transfer ownership of the Roles manager.\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"zero address\");\n        emit OwnerTransferred(owner, newOwner);\n        grantRole(ADMIN_ROLE, newOwner);\n        revokeRole(ADMIN_ROLE, owner); \n        owner = newOwner;\n    }\n}"
      }
    }
  }
}