/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "./common.js"
  

  export interface RequestInterface extends Interface {
    getFunction(nameOrSignature: "appointAuditor" | "appointExecutor" | "assignAuditResult" | "assignResult" | "auditor" | "auditorResultHash" | "commandHash" | "currentState" | "executor" | "faultyResult" | "getInformation" | "owner" | "reputation" | "resultHash" | "roles"): FunctionFragment;

    getEvent(nameOrSignatureOrTopic: "AuditorAssigned" | "AuditorResultAssigned" | "ExecutorAssigned" | "FaultyCalculationDetected" | "FaultyCalculationFixed" | "RequestFinished" | "ResultAssigned"): EventFragment;

    encodeFunctionData(functionFragment: 'appointAuditor', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'appointExecutor', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'assignAuditResult', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'assignResult', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'auditor', values?: undefined): string;
encodeFunctionData(functionFragment: 'auditorResultHash', values?: undefined): string;
encodeFunctionData(functionFragment: 'commandHash', values?: undefined): string;
encodeFunctionData(functionFragment: 'currentState', values?: undefined): string;
encodeFunctionData(functionFragment: 'executor', values?: undefined): string;
encodeFunctionData(functionFragment: 'faultyResult', values?: undefined): string;
encodeFunctionData(functionFragment: 'getInformation', values?: undefined): string;
encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
encodeFunctionData(functionFragment: 'reputation', values?: undefined): string;
encodeFunctionData(functionFragment: 'resultHash', values?: undefined): string;
encodeFunctionData(functionFragment: 'roles', values?: undefined): string;

    decodeFunctionResult(functionFragment: 'appointAuditor', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'appointExecutor', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'assignAuditResult', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'assignResult', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'auditor', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'auditorResultHash', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'commandHash', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'currentState', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'executor', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'faultyResult', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getInformation', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'reputation', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'resultHash', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'roles', data: BytesLike): Result;
  }

  
    export namespace AuditorAssignedEvent {
      export type InputTuple = [account: AddressLike];
      export type OutputTuple = [account: string];
      export interface OutputObject {account: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace AuditorResultAssignedEvent {
      export type InputTuple = [hash: BytesLike, by: AddressLike];
      export type OutputTuple = [hash: string, by: string];
      export interface OutputObject {hash: string, by: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace ExecutorAssignedEvent {
      export type InputTuple = [account: AddressLike];
      export type OutputTuple = [account: string];
      export interface OutputObject {account: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace FaultyCalculationDetectedEvent {
      export type InputTuple = [auditedBy: AddressLike, calculatedBy: AddressLike, executionHash: BytesLike, auditHash: BytesLike];
      export type OutputTuple = [auditedBy: string, calculatedBy: string, executionHash: string, auditHash: string];
      export interface OutputObject {auditedBy: string, calculatedBy: string, executionHash: string, auditHash: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace FaultyCalculationFixedEvent {
      export type InputTuple = [auditedBy: AddressLike, calculatedBy: AddressLike];
      export type OutputTuple = [auditedBy: string, calculatedBy: string];
      export interface OutputObject {auditedBy: string, calculatedBy: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace RequestFinishedEvent {
      export type InputTuple = [calculatedBy: AddressLike, auditedBy: AddressLike, resultHash: BytesLike];
      export type OutputTuple = [calculatedBy: string, auditedBy: string, resultHash: string];
      export interface OutputObject {calculatedBy: string, auditedBy: string, resultHash: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace ResultAssignedEvent {
      export type InputTuple = [hash: BytesLike, by: AddressLike];
      export type OutputTuple = [hash: string, by: string];
      export interface OutputObject {hash: string, by: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

  export interface Request extends BaseContract {
    
    connect(runner?: ContractRunner | null): Request;
    waitForDeployment(): Promise<this>;

    interface: RequestInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    appointAuditor: TypedContractMethod<
      [potentialAuditor: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    appointExecutor: TypedContractMethod<
      [potentialExecutor: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    assignAuditResult: TypedContractMethod<
      [calculatedResultHash: BytesLike, ],
      [void],
      'nonpayable'
    >
    

    
    assignResult: TypedContractMethod<
      [calculatedResultHash: BytesLike, ],
      [void],
      'nonpayable'
    >
    

    
    auditor: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    auditorResultHash: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    commandHash: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    currentState: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    executor: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    faultyResult: TypedContractMethod<
      [],
      [boolean],
      'view'
    >
    

    
    getInformation: TypedContractMethod<
      [],
      [[bigint, string, string, string, string, string, string, boolean] & {state: bigint, owner_: string, executor_: string, auditor_: string, commandHash_: string, resultHash_: string, auditorResultHash_: string, faultyResult_: boolean }],
      'view'
    >
    

    
    owner: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    reputation: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    resultHash: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    roles: TypedContractMethod<
      [],
      [string],
      'view'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'appointAuditor'): TypedContractMethod<
      [potentialAuditor: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'appointExecutor'): TypedContractMethod<
      [potentialExecutor: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'assignAuditResult'): TypedContractMethod<
      [calculatedResultHash: BytesLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'assignResult'): TypedContractMethod<
      [calculatedResultHash: BytesLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'auditor'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'auditorResultHash'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'commandHash'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'currentState'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'executor'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'faultyResult'): TypedContractMethod<
      [],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'getInformation'): TypedContractMethod<
      [],
      [[bigint, string, string, string, string, string, string, boolean] & {state: bigint, owner_: string, executor_: string, auditor_: string, commandHash_: string, resultHash_: string, auditorResultHash_: string, faultyResult_: boolean }],
      'view'
    >;
getFunction(nameOrSignature: 'owner'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'reputation'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'resultHash'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'roles'): TypedContractMethod<
      [],
      [string],
      'view'
    >;

    getEvent(key: 'AuditorAssigned'): TypedContractEvent<AuditorAssignedEvent.InputTuple, AuditorAssignedEvent.OutputTuple, AuditorAssignedEvent.OutputObject>;
getEvent(key: 'AuditorResultAssigned'): TypedContractEvent<AuditorResultAssignedEvent.InputTuple, AuditorResultAssignedEvent.OutputTuple, AuditorResultAssignedEvent.OutputObject>;
getEvent(key: 'ExecutorAssigned'): TypedContractEvent<ExecutorAssignedEvent.InputTuple, ExecutorAssignedEvent.OutputTuple, ExecutorAssignedEvent.OutputObject>;
getEvent(key: 'FaultyCalculationDetected'): TypedContractEvent<FaultyCalculationDetectedEvent.InputTuple, FaultyCalculationDetectedEvent.OutputTuple, FaultyCalculationDetectedEvent.OutputObject>;
getEvent(key: 'FaultyCalculationFixed'): TypedContractEvent<FaultyCalculationFixedEvent.InputTuple, FaultyCalculationFixedEvent.OutputTuple, FaultyCalculationFixedEvent.OutputObject>;
getEvent(key: 'RequestFinished'): TypedContractEvent<RequestFinishedEvent.InputTuple, RequestFinishedEvent.OutputTuple, RequestFinishedEvent.OutputObject>;
getEvent(key: 'ResultAssigned'): TypedContractEvent<ResultAssignedEvent.InputTuple, ResultAssignedEvent.OutputTuple, ResultAssignedEvent.OutputObject>;

    filters: {
      
      'AuditorAssigned(address)': TypedContractEvent<AuditorAssignedEvent.InputTuple, AuditorAssignedEvent.OutputTuple, AuditorAssignedEvent.OutputObject>;
      AuditorAssigned: TypedContractEvent<AuditorAssignedEvent.InputTuple, AuditorAssignedEvent.OutputTuple, AuditorAssignedEvent.OutputObject>;
    

      'AuditorResultAssigned(bytes32,address)': TypedContractEvent<AuditorResultAssignedEvent.InputTuple, AuditorResultAssignedEvent.OutputTuple, AuditorResultAssignedEvent.OutputObject>;
      AuditorResultAssigned: TypedContractEvent<AuditorResultAssignedEvent.InputTuple, AuditorResultAssignedEvent.OutputTuple, AuditorResultAssignedEvent.OutputObject>;
    

      'ExecutorAssigned(address)': TypedContractEvent<ExecutorAssignedEvent.InputTuple, ExecutorAssignedEvent.OutputTuple, ExecutorAssignedEvent.OutputObject>;
      ExecutorAssigned: TypedContractEvent<ExecutorAssignedEvent.InputTuple, ExecutorAssignedEvent.OutputTuple, ExecutorAssignedEvent.OutputObject>;
    

      'FaultyCalculationDetected(address,address,bytes32,bytes32)': TypedContractEvent<FaultyCalculationDetectedEvent.InputTuple, FaultyCalculationDetectedEvent.OutputTuple, FaultyCalculationDetectedEvent.OutputObject>;
      FaultyCalculationDetected: TypedContractEvent<FaultyCalculationDetectedEvent.InputTuple, FaultyCalculationDetectedEvent.OutputTuple, FaultyCalculationDetectedEvent.OutputObject>;
    

      'FaultyCalculationFixed(address,address)': TypedContractEvent<FaultyCalculationFixedEvent.InputTuple, FaultyCalculationFixedEvent.OutputTuple, FaultyCalculationFixedEvent.OutputObject>;
      FaultyCalculationFixed: TypedContractEvent<FaultyCalculationFixedEvent.InputTuple, FaultyCalculationFixedEvent.OutputTuple, FaultyCalculationFixedEvent.OutputObject>;
    

      'RequestFinished(address,address,bytes32)': TypedContractEvent<RequestFinishedEvent.InputTuple, RequestFinishedEvent.OutputTuple, RequestFinishedEvent.OutputObject>;
      RequestFinished: TypedContractEvent<RequestFinishedEvent.InputTuple, RequestFinishedEvent.OutputTuple, RequestFinishedEvent.OutputObject>;
    

      'ResultAssigned(bytes32,address)': TypedContractEvent<ResultAssignedEvent.InputTuple, ResultAssignedEvent.OutputTuple, ResultAssignedEvent.OutputObject>;
      ResultAssigned: TypedContractEvent<ResultAssignedEvent.InputTuple, ResultAssignedEvent.OutputTuple, ResultAssignedEvent.OutputObject>;
    
    };
  }